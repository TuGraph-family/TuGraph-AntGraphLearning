syntax = "proto3";

// package (not affect python)
package agl.proto.sampler;

// java
option java_package = "com.antfin.agl.proto.sampler";
option java_outer_classname = "GraphSampler";

option cc_enable_arenas = true;

enum CmpOp {
  CMP_UNKNOWN = 0;
  LT = 1;
  LE = 2;
  EQ = 3;
  GT = 4;
  GE = 5;
  NE = 6;
  IN = 7;
  NOT_IN = 8;
}

enum LogicOp {
  LOGIC_UNKNOWN = 0;
  AND = 1;
  OR = 2;
  NOT = 3;
}

enum ArithmeticOp {
  ARITH_UNKNOWN = 0;
  MINUS = 1;
  PLUS = 2;
  STAR = 3;
  DIV = 4;
  MOD = 5;
}

enum VariableSource {
  VAR_UNKNOWN = 0;
  INDEX = 1;
  SEED = 2;
  FRONTIER = 3;
  EDGE = 4;
}

message Element {
  message Variable {
    string name = 1;
    VariableSource source = 2;
    int32 index = 3;
  }

  message Number {
    oneof data {
      float f = 1;
      int64 i = 2;
      string s = 3;
    }
  }

  oneof symbol {
    Variable var = 1;
    Number num = 2;
    ArithmeticOp op = 3;
  }
}

// The left and right lists could contain variables, constants, and operators, arranged in reverse polish notation.
// The comparison operator determines how the two lists are compared.
// The original formula is converted into reverse polish notation, where the operands follow their operators.
// For example, the original inequation is index.time - seed.1 / index.time2 + seed.3 >=  10 * seed.2,
// the converted left list is [index.time, seed.1, seed.2, /, -, seed.3, +]
// the converted right list is [10, seed.2, *]
// the op is GREATER_EQ
message CmpExp {
  repeated Element lhsRPN = 1;
  repeated Element rhsRPN = 2;
  CmpOp op = 3;
}

// Similar to CmpExp, LogicExps represents logic expressions in reverse polish notation manner,
// where operands follow their logic sub-expressions.
// For example, the original logic expressions are: CmpExp1 OR CmpExp2 AND CmpExp3,
// the converted list is [CmpExp1, CmpExp2, CmpExp3, AND, OR]
message LogicExps {
  message ExpOrOp {
    oneof data {
      CmpExp exp = 1;
      LogicOp op = 2;
    }
  }
  
  repeated ExpOrOp expRPN = 1;
}
