syntax = "proto3";

// java
option java_package = "com.antfin.ai.alps.graph.flat.sample";
option java_outer_classname = "SampleMeta";
option java_multiple_files = true;

// python/cpp
package alps.graph_ml.proto.sample;

option cc_enable_arenas = true;

enum CmpOp {
  LESS = 0;
  LESS_EQ = 1;
  EQ = 2;
  GREATER = 3;
  GREATER_EQ = 4;
  NOT_EQ = 5;
  IN = 6;
  NOT_IN = 7;
}

enum LogicOp {
  AND = 0;
  OR = 1;
  NOT = 2;
}

enum ArithmeticOp {
  MINUS = 0;
  PLUS = 1;
  STAR = 2;
  DIV = 3;
  MOD = 4;
}

enum VariableSource {
  INDEX = 0;
  SEED = 1;
  FRONTIER = 2;
  EDGE = 3;
}

message Element {
  message Variable {
    string name = 1;
    VariableSource source = 2;
    int32 index = 3;
  }

  message Number {
    oneof data {
      float f = 1;
      int64 i = 2;
      string s = 3;
    }
  }

  oneof symbol {
    Variable v = 1;
    Number n = 2;
    ArithmeticOp op = 3;
  }
}

// The left and right lists could contain variables, constants, and operators, arranged in reverse polish notation.
// The comparison operator determines how the two lists are compared.
// The original formula is converted into reverse polish notation, where the operands follow their operators.
// For example, the original inequation is index.time - seed.1 / index.time2 >=  10 * seed.2,
// the converted left list is [index.time, seed.1, seed.2, /, -]
// the converted right list is [10, seed.2, *]
// the op is GREATER_EQ
message CmpExp {
  repeated Element leftFormulaRPN = 1;
  repeated Element rightFormulaRPN = 2;
  CmpOp op = 3;
}

// Similar to CmpExp, LogicExps represents logic expressions in reverse polish notation manner,
// where operands follow their logic sub-expressions.
// For example, the original logic expressions are: CmpExp1 OR CmpExp2 AND CmpExp3,
// the converted list is [CmpExp1, CmpExp2, CmpExp3, AND, OR]
message LogicExps {
  message ExpOrOp {
    oneof data {
      CmpExp exp = 1;
      LogicOp op = 2;
    }
  }
  
  repeated ExpOrOp expRPN = 1;
}
